# 搜索推理技术

## 搜索的定义

### 适用情况：

不良结构或非结构化问题；难以获得求解所需的全部信息；更没有现成的算法可供求解使用。

### 概念：

依靠经验，利用已有知识，根据问题的实际情况，不断寻找可利用知识，从而构造一条代价最小的推理路线，使问题得以解决的过程称为搜索

### 搜索的类型：

#### 1 按是否使用启发式信息：

1. 盲目搜索：按预定的控制策略进行搜索，在搜索过程中获得的中间信息并不改变控制策略。
2. 启发式搜索：在搜索中加入了与问题有关的启发性信息，用于指导搜索朝着最有希望的方向前进，加速问题的求解过程并找到最优解。

#### 2 按问题的表示方式：

1. 状态空间搜索：用状态空间法来求解问题所进行的搜索
2. 与或树搜索：用问题归约法来求解问题时所进行的搜索

## 图搜索

### 搜索过程

1. 必须记住下一步还可以走哪些点：OPEN表(记录还没有扩展的点)
2. 必须记住哪些点走过了：CLOSED表(记录已经扩展的点)
3. 必须记住从目标返回的路径:每个表示状态的节点结构中必须有指向父节点的指针

### 性能指标

1. 完备性—当问题有解时，算法是否保证找到一个解
2. 最优性—算法是否能找到一个最优解(路径耗散函数值最小的路径)
3. 时间复杂性—找到一个解需要花费多少时间
4. 空间复杂性—在搜索过程中需要占用多少内存


### 无信息搜索（Uninformed search ）

盲目搜索(a.k.a. blind search)：不使用任何与问题有关的经验信息

#### 特点：

1. 搜索过程中不使用与问题有关的经验信息
2. 搜索效率低
3. 不适合大空间的实际问题求解

#### 分类：

1. 宽度优先搜索Breadth-first search

    *搜索过程：*

    1. 首先扩展根节点
    2. 接着扩展根节点的所有后继节点
    3. 然后再扩展后继节点的后继，依此类推
    4. 在下一层任何节点扩展之前搜索树上的本层深度的所有节点都已经被扩展

    **Open表是一个FIFO队列**

    *性能：*

    1. 完备性：有
    2. 时间：O(b^d)
    3. 空间：O(b^(d+1))
    4. 最优：如果每步扩展的代价相同时，宽度优先搜索能找到最优解

2. 深度优先搜索Depth-first search

    *搜索过程：*

    1. 总是扩展搜索树的当前扩展分支(边缘)中最深的节点
    2. 搜索直接伸展到搜索树的最深层，直到那里的节点没有后继节点
    3. 那些没有后继节点的节点扩展完毕就从边缘中去掉
    4. 然后搜索算法回退下一个还有未扩展后继节点的上层节点继续扩展
    5. 
    **Open表是一个栈**

    *性能：*

    1. 完备性：没有
    2. 时间：O(b^m),b是分支数，m是最大深度
    3. 空间：O(bm)
    4. 最优：没有

3. 有界深度优先搜索Depth-limited search

    就是给深度优先搜索加了一个深度的限制

    *性能：*

    1. 完备性：没有
    2. 时间：O(b^l)
    3. 空间：O(bl)
    4. 最优：没有

4. 等代价搜索Uniform-cost search

    *搜索过程*

    1. 把根节点放入open表
    2. 在open取当前代价最小的点，扩展后继节点
    3. 重复 2

    **Open表是一个优先队列**

    *性能：*

    1. 完备性：有
    2. 时间：O(b^(C*/з))，C是最终的深度d的代价，з是最小的两相邻点间代价
    3. 空间：O(b^(C*/з))
    4. 最优：是

5. 迭代加深搜索Iterative deepening search.

    *搜索过程*

    1. 设置深度为1
    2. 使用有界深度优先搜索，找到即退出
    3. 深度加1，重复2步骤

    *性能：*

    1. 完备性：有
    2. 时间：O(b^d)
    3. 空间：O(bd)
    4. 最优：路径代价是节点深度的非递增函数时是最优的

### 启发式搜索

有信息搜索：利用启发式信息来提高搜索效率

1. Heutistic function启发函数h(n)的值是对当前状态n的一个估计，表示对当前节点的评估
2. Cost function f(n),评价函数
3. g(n)，表示从起始节点到当前节点的代价
4. 最佳优先搜索算法过程，open表中需要保存节点以及节点的f(n)，在扩展的时候使用open表中f(n)最小的值

### f(n) 的不同定义与算法

1. f(n)=g(n) 等代价搜索(UCS)，不利用h(n)，是无信息搜索

    只考虑从源节点到当前节点的代价作为估价,Dijkstral

2. f(n)=h(n)贪婪优先搜索(Greedy best first)

    只考虑从当前节点到终点的代价作为估价

    **性能：**

    1. 完备性：无，相当与DFS，因为会被启发式信息误导
    2. 时间：O(b^m)
    3. 空间：O(b^m)
    4. 最优：没有

3. f(n)=g(n)+h(n) A算法


    同时考虑从源节点到当前节点的代价作为估价、从当前节点到终点的代价作为估价

    **特征：**

    对h (n)无限制，虽提高了算法效率，但不能保证找到最优解
    不合适的h (n)定义会导致算法找到不解

    **性能：**

    不完备，不最优

4. A*算法

    估价函数满足一定限制条件的算法称为A*算法

    f (n) = g (n) + h (n)，其中h(n)是不大于实际代价h*(n)的估价

    h越接近h*, 扩展的节点越少

    **性能：**

    1. 完备性：有
    2. 时间：路径长度的指数
    3. 空间：全部节点保存
    4. 最优：有

### 局部搜索

全局搜索(Global search)也称系统搜索(Systematic search) 寻找的是从初始节点到目标节点的路径

然后执行解路径所对应的操作序列

BFS, DFS, IDS, UCS, Greedy Best-First, A, A*, etc. 

但很多问题并不需要找最优路径，而只需要找到最优状态——优化问题

局部搜索非常适合解决优化问题，也是一类常用的启发式搜索策略
